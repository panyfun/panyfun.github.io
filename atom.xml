<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pany&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://pany.fun/"/>
  <updated>2018-10-18T08:30:28.487Z</updated>
  <id>http://pany.fun/</id>
  
  <author>
    <name>Pany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类方法转发</title>
    <link href="http://pany.fun/post/%E7%B1%BB%E6%96%B9%E6%B3%95Forward/"/>
    <id>http://pany.fun/post/类方法Forward/</id>
    <published>2018-10-18T08:03:43.000Z</published>
    <updated>2018-10-18T08:30:28.487Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约750字，将会介绍对类方法的消息转发，它能帮助我们解决类方法的unrecognized selector crash，或是应对一些其它需要转发的场景</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p>如果你对消息转发流程还不熟悉，请先行了解 <a href="https://blog.ibireme.com/2013/11/26/objective-c-messaging/" target="_blank" rel="noopener">Objective-C 中的消息与消息转发</a></p><p>熟悉以后我们知道，其实消息的转发可以非常简单，简单到可能几行代码就能搞定</p><pre><code class="objective-c">- (id)forwardingTargetForSelector:(SEL)aSelector {    // TODO: forward    return target;}</code></pre><p>这就是一个最简单的消息转发方案</p><h2 id="问题"><a href="#问题" class="headerlink" title="# 问题"></a># 问题</h2><p>我司最近有一个需求需要用到消息转发，于是我们也是啪啪啪就敲上了上面的几行代码，分分钟搞定需求，一切都很顺利。</p><p>但是我们在测试类方法的时候，问题出现了—— forward方法居然没有执行🤔</p><p>按到理解，NSObject是root类，那么所有找不到的方法应该都能走到NSObject</p><p>于是我们把上面的forward方法写在了NSObject的分类里进行测试 (正常开发不建议在分类中重写如此敏感的方法)</p><p>分类中的方法会覆盖原类中的方法，也就是说，我们在分类中写的forward方法能够拿到所有的forward消息</p><p>然后我们再次测试类方法，发现即使是分类里的forward方法，也没有被执行，但是测试实例方法确实是能够执行到的</p><p>查询NSObject.h也没有发现任何能够简单转发类方法的接口</p><h2 id="真相"><a href="#真相" class="headerlink" title="# 真相"></a># 真相</h2><p>真相当然只有一个，我们怀疑forward没生效是因为消息链路中有可疑人物已经处理了forward，最可疑的当然是NSObject</p><p>考虑到我们测试实例方法可行而类方法不可行，我们将目标进一步定位在了NSObject的meta类上</p><p>所以我们自然而然的想要给NSObject的原来添加forward方法，于是我们在NSObject的分类中硬塞了一个这样的方法</p><pre><code class="objective-c">+ (id)forwardingTargetForSelector:(SEL)aSelector {    // TODO: forward    return target;}</code></pre><p>需要注意，虽然它跟前面的forward方法名字完全相同，但是它是类方法，所以它会被添加到NSObject的meta类的方法列表中</p><p>再次测试类方法，生效！</p><p>真相只有一个：NSObject的meta类中包含方法forwardingTargetForSelector，即NSObject还有一个类方法版本的forward，但是它并没有开放在.h中</p><h2 id="源码"><a href="#源码" class="headerlink" title="# 源码"></a># 源码</h2><p>apple没有开放不用怕，毕竟runtime是开源的，我们查询了<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/NSObject.mm#L2102" target="_blank" rel="noopener">NSObject的源码</a></p><pre><code class="objective-c">// Line: 2102+ (id)forwardingTargetForSelector:(SEL)sel {    return nil;}- (id)forwardingTargetForSelector:(SEL)sel {    return nil;}</code></pre><p>真相大白</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约750字，将会介绍对类方法的消息转发，它能帮助我们解决类方法的unrecognized selector crash，或是应对一些其它需要转发的场景&lt;/p&gt;
    
    </summary>
    
      <category term="专业填坑" scheme="http://pany.fun/categories/%E4%B8%93%E4%B8%9A%E5%A1%AB%E5%9D%91/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>基于策略模式设计的文件上传组件</title>
    <link href="http://pany.fun/post/%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%84%E4%BB%B6/"/>
    <id>http://pany.fun/post/基于策略模式设计的文件上传组件/</id>
    <published>2018-06-26T07:46:00.000Z</published>
    <updated>2018-09-21T01:55:16.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约1150字，将会简单讲述基于策略模式设计的文件上传组件的一些设计思路以及使用方式。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p>本文相关Demo: <a href="https://github.com/panyfun/PZFileUploader" target="_blank" rel="noopener">PZFileUploader</a></p><p>Demo中仅实现了整体框架，部分诸如 token请求过程、请求返回的数据解析过程 等需自行根据实际业务场景实现</p><h2 id="文件上传需求"><a href="#文件上传需求" class="headerlink" title="#文件上传需求"></a>#文件上传需求</h2><p>文件上传功能是大多数项目都会涉及到的，在我司项目中，文件上传功能有一下几个痛点</p><ul><li>上传类型多，图片(头像、识别)、音频、视频、通讯录、日志 等等</li><li>不同类型文件有不同上传方式，如：通讯录、日志上传到自己服务器，媒体文件上传七牛</li><li>不同类型文件请求七牛token时有不同参数要求(如头像需要单独标记)</li><li>不同类型文件上传时带参数可能不同</li><li>不同类型文件上传以后返回的json数据结构不同(历史问题)</li><li>文件类型随时可能扩展</li></ul><p>这些问题导致我司的文件上传组件耦合越来越严重，维护成本越来越高</p><h2 id="以传统思路看问题所在"><a href="#以传统思路看问题所在" class="headerlink" title="#以传统思路看问题所在"></a>#以传统思路看问题所在</h2><p>按照传统的思路，我们可能这样设计上传功能</p><pre><code>// 设计一个枚举，用来标识不同的上传文件的类型typedef enum : NSUInteger {    FileType_Image,    FileType_Video,    FileType_Log,} FileType;// token的Url- (NSString *)tokenUrlWithType:(FileType)type {    NSString *urlStr;    switch (type) {        case FileType_Image:            urlStr = @&quot;xxxxx1&quot;;            break;        case FileType_Video:            urlStr = @&quot;xxxxx2&quot;;            break;        case FileType_Log:            urlStr = @&quot;xxxxx3&quot;;            break;    }    return urlStr;}// 请求的参数- (NSDictionary *)paramsWithType:(FileType)type {    switch (type) {        case FileType_Image:            return xxx1;            break;        case FileType_Video:            return xxx2;            break;        case FileType_Log:            return xxx3;            break;    }}// ......</code></pre><p>首先我们会设计一个枚举，标识不同类型的文件</p><p>随后，为了应对各种场景，例如不同文件 上传到哪里、请求token的url、请求token的参数 等等，我们需要不断的进行类型的判断</p><p>这无疑会导致我们有大量的判断需要写，开发工作繁杂。而且一旦后期增加一种上传类型，就会需要添加枚举，需要添加所有的条件判断，维护成本极高。而且这种写法很难作为多app平台的独立组件使用，它的一些逻辑已经深入到了需求细节，耦合度高。</p><h2 id="PZFileUploader的设计思路"><a href="#PZFileUploader的设计思路" class="headerlink" title="#PZFileUploader的设计思路"></a>#PZFileUploader的设计思路</h2><p>在前面<a href="http://pany.fun/post/策略模式/">策略模式的文章</a>中，我明们已经提到了策略模式的抽象思想，这里我们直接应用。具体代码可以直接查看<a href="https://github.com/panyfun/PZFileUploader" target="_blank" rel="noopener">PZFileUploaderDemo</a></p><p>首先，我们按照策略模式的抽象思路，摒弃了枚举，并以类代替，然后在基类PZFileTypeBase中提供了上传过程中各个流程的默认实现，并对外开放了两大主要流程——上传流程 和 token请求流程，以满足子类的自定义需求，子类只需要继承并覆盖对应方法就可以实现流程细节的自定义。</p><p>另外独立于上传，还单独设计了token池的功能，用于处理次token请求返回多个token的业务场景，为不同的文件类型维护独立的token池。</p><h2 id="PZFileUploader怎么用"><a href="#PZFileUploader怎么用" class="headerlink" title="#PZFileUploader怎么用"></a>#PZFileUploader怎么用</h2><h4 id="基本使用方式"><a href="#基本使用方式" class="headerlink" title="- 基本使用方式"></a>- 基本使用方式</h4><p>PZFileUploader主要需要关注的类有两个</p><ul><li><p>PZFileUploader    </p><p>这是上传工具主类，以单例形式提供，包含了外部上传文件需要调用的主接口以及token请求的url配置接口</p></li><li><p>PZFileTypeBase     </p><p>用于区分上传的文件类型的基类，其内部已经实现了上传的主要流程，其upload接口提供给PZFileUploader调用。</p></li></ul><p>上传文件时，调用PZFileUploader中的upload接口，并传入相应文件和type实例</p><h4 id="如何添加文件类型支持"><a href="#如何添加文件类型支持" class="headerlink" title="- 如何添加文件类型支持"></a>- 如何添加文件类型支持</h4><p>当需要添加新的上传文件类型时，非常的简单，只需要新建一个type类并继承到PZFileTypeBase即可</p><h4 id="如何自定义token请求流程-上传流程"><a href="#如何自定义token请求流程-上传流程" class="headerlink" title="- 如何自定义token请求流程/上传流程"></a>- 如何自定义token请求流程/上传流程</h4><p>在自己的type子类中重写<code>- requestToken:</code>方法即可自定义token请求流程，token请求所需的参数可以作为type的属性。参考 PZFileTypeVideo.m</p><p>在自己的type子类中重写<code>- upload:withParams:</code>方法即可自定义上传流程以及上传完成后的数据解析。参考 PZFileTypeCrashLog.m</p><h4 id="文件组织建议"><a href="#文件组织建议" class="headerlink" title="- 文件组织建议"></a>- 文件组织建议</h4><p>为了达到高度解耦以及新平台的易移植特性，建议将PZFileUploader类、PZUploadToken类、PZFileTypeBase类作为平台型中间件以方便新app的快速移植，而其它的PZFileTypeBase的子类，作为业务型中间件，以满足更加贴合业务需求的上传功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约1150字，将会简单讲述基于策略模式设计的文件上传组件的一些设计思路以及使用方式。&lt;/p&gt;
    
    </summary>
    
      <category term="开源共勉" scheme="http://pany.fun/categories/%E5%BC%80%E6%BA%90%E5%85%B1%E5%8B%89/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="http://pany.fun/post/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://pany.fun/post/策略模式/</id>
    <published>2018-06-25T03:27:30.000Z</published>
    <updated>2018-09-21T01:55:16.897Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约1600字，将会通俗的介绍什么是策略模式，以及策略模式的优缺点与适用的场景</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><h2 id="什么是策略"><a href="#什么是策略" class="headerlink" title="#什么是策略"></a>#什么是策略</h2><p>要理解策略模式，首先要知道什么是策略。</p><p>通俗的来说，策略也可以理解为决策，即根据某些条件做出某些行为。例如 “兵来将挡，水来土掩”，这就是策略。</p><p>我们尝试将它转换为伪代码来理解编程语言中的策略</p><pre><code>if (兵) {    将挡} else if (水) {    土掩}</code></pre><p>编程语言中，策略往往关联到条件语句。<strong>一个条件语句的分支 即是 一个策略</strong>，多个条件语句则能够组成一个策略组。</p><h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="#什么是策略模式"></a>#什么是策略模式</h2><p>策略模式可以理解为对条件语句的一种解耦优化。相同的需求，使用策略模式相比使用条件语句而言，更易维护、更易扩展、且低耦合。</p><blockquote><p>关于什么是<a href="https://zh.wikipedia.org/wiki/策略模式" target="_blank" rel="noopener">策略模式的维基定义</a></p><p>策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法</p></blockquote><p>对策略模式很难三言两语的理解清楚，我们将在后续讲解中去理解。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="#抽象"></a>#抽象</h2><p>一个事情涉及到抽象，往往抽象部分就会成为这个事情的核心，也会成为相对难以理解的部分。例如从c进化到c++时，抽象就是c++的核心思想。同样的，抽象也是策略模式的核心思想。</p><p>我们将通过常规的条件语句写法以及策略模式写法来理解 抽象</p><h4 id="条件语句写法"><a href="#条件语句写法" class="headerlink" title="- 条件语句写法"></a>- 条件语句写法</h4><p>假设我们在某个文件1中，有这么一个判断需求</p><pre><code>if (x == a) {    // do something a} else if (x == b) {    // do something b} else if (x == c) {    // do something c} else {    // do something default}</code></pre><p>而在某个文件2中，我们又有这么一个需求</p><pre><code>if (x == a) {    // do something a1} else if (x == b) {    // do something b1} else if (x == c) {    // do something c1} else {    // do something default1}</code></pre><p>更复杂的情况下，我们可能还会有文件3、文件4 等等 都需要进行这种判断然后执行不同的行为，又因为不在同一个文件而无法整合。</p><blockquote><p>这种需求并不是我们YY出来的，而是真实存在的。例如我们上传文件时，就需要根据文件类型判断请求token的url及参数，也需要根据文件类型判断上传到哪里去(例如图片上传到七牛，日志上传到自己服务器)，也需要根据文件类型处理上传参数，甚至还需要根据文件类型来判断怎么处理数据的解析</p><p><a href="http://pany.fun/post/基于策略模式设计的文件上传组件/">基于策略模式的文件上传组件</a></p></blockquote><p>这种写法是最常见也是我们最先想到的，但是它的问题也是显而易见的，一旦后期需要添加一个条件(例如x==d)，我们需要给每个文件中的条件语句都进行添加，维护成本很高而且容易遗漏</p><h4 id="策略模式的抽象"><a href="#策略模式的抽象" class="headerlink" title="- 策略模式的抽象"></a>- 策略模式的抽象</h4><p>策略模式的优化点在于，充分利用面向对象的多态特性，即使相同的方法(相同的判断条件)，不同的子类也能够有不同的实现(执行不同的行为)</p><p>策略模式的抽象逻辑</p><ul><li>将相同的判断条件(例如x==a)，抽象为一个类</li><li>将一处判断逻辑封装为一个实例方法</li><li>将相同判断条件下的不同行为算法(例如 do a，do a1)，抽象为不同子类下对父类实例方法的覆盖</li></ul><p>我们将通过代码来更深层次的理解这两个抽象</p><h4 id="策略模式写法"><a href="#策略模式写法" class="headerlink" title="- 策略模式写法"></a>- 策略模式写法</h4><pre><code>// 抽象Class Base {    - doSth {        // do something default    }    - doSth1 {        // do something default1    }}Class A : Base {    - doSth {        // do something a    }    - doSth1 {        // do something a1    }}Class B : Base {    - doSth {        // do something b    }    - doSth1 {        // do something b1    }}Class C : Base {    - doSth {        // do something c    }    - doSth1 {        // do something c1    }}</code></pre><p>我们将条件语句中的default条件抽象成了Base类，因为我们条件语句写法中有两处判断逻辑(文件1和文件2，共2次)，所以我们的Base类中提供了两个方法，doSth和doSth1，doSth中执行的是文件1中的default条件下的行为算法，doSth1中执行的是文件2中的default条件下的行为算法。对于条件x==a、x==b、x==c 我们同样进行了一系列抽象。</p><p>抽象结束后，我们当然需要判断能够执行，那么在抽象模式下我们如何执行判断</p><pre><code>(_kindof Class Base) x// 文件1中[x doSth];// 文件2中[x doSth1];</code></pre><p>我们无需明确的知道x是什么类，只需要确定它是我们的条件类Base或其子类即可</p><p>当我们调用某个方法时，由于多态的特性，不同的类能够执行自己的实现，也就达到了根据情况执行行为的目的。</p><h4 id="策略模式的扩展"><a href="#策略模式的扩展" class="headerlink" title="- 策略模式的扩展"></a>- 策略模式的扩展</h4><p>前面我们提到了扩展条件d，对于条件语句来说，是非常容易出错的，但是对于策略模式来说，它非常简单。</p><p>我们只需要添加Class D，并实现相应的doSth、doSth1即可。维护成本非常低。</p><h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="#策略模式的优缺点"></a>#策略模式的优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="- 优点"></a>- 优点</h4><ul><li>易扩展，维护成本低</li><li>低耦合，将判断条件及行为从文件中统一到一个类中</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="- 缺点"></a>- 缺点</h4><ul><li>会导致类/文件增加…</li></ul><h2 id="策略模式适合的场景"><a href="#策略模式适合的场景" class="headerlink" title="#策略模式适合的场景"></a>#策略模式适合的场景</h2><p>通过上面优缺点其实很容易总结出策略模式的适用场景</p><p>当相同条件，我们只需要进行一次判断逻辑的时候，显然条件语句是更合适的，它不会增加类也不会增加文件，且因为只有一处所以没有太多维护成本</p><p>当相同条件，我们需要多次判断执行不同行为的时候，策略模式是更合适的，它能够解除耦合并减少后期维护成本</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约1600字，将会通俗的介绍什么是策略模式，以及策略模式的优缺点与适用的场景&lt;/p&gt;
    
    </summary>
    
      <category term="日常学习" scheme="http://pany.fun/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://pany.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Extension中属性合成的坑</title>
    <link href="http://pany.fun/post/Extension%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%90%88%E6%88%90%E7%9A%84%E5%9D%91/"/>
    <id>http://pany.fun/post/Extension中属性合成的坑/</id>
    <published>2018-06-15T03:51:21.000Z</published>
    <updated>2018-09-21T01:55:16.894Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约1200字，将会介绍访问扩展Extension中属性时遇到unrecognized selector的坑。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p>首先关于Extension，推荐一篇<a href="http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/" target="_blank" rel="noopener">SunnyXX的文章</a>，其中较为详细的讲了Extension的原理及一些用法。本次这个坑发现，也是在我们尝试使用Extension进行一些分离工作的时候遇到的。</p><h2 id="坑"><a href="#坑" class="headerlink" title="#坑"></a>#坑</h2><p>我们在Framework的开发过程中，经常会希望一个类的某些东西不要开放出去，这种需求场景往往我们会使用Extension来实现。在这次的实践中，我们遇到了一个 <strong>编译通过，在类的外部访问类的Extension中的属性时，出现unrecognized selector，但在类的内部访问时正确</strong> 的问题。而这与我们对于Extension的理解是不太相符的。</p><h2 id="还原"><a href="#还原" class="headerlink" title="#还原"></a>#还原</h2><p>为了搞清楚问题所在，我们搭建了一个更简单更干净的<a href="https://github.com/panyfun/BlogDemo/tree/master/20180515_ExtensionDemo" target="_blank" rel="noopener">Demo工程</a>进行还原与探究。</p><p>Step 0 基本搭建</p><p>​    首先我们在工程中创建了一个Woman类，并填了一个Woman+Secret的扩展 。Woman.h中添加了一个name属性(name属性主要作为参照)，Woman+Secret.h中我们添加了一个age属性。</p><p>Step1 再现错误</p><p>​    我们在viewController中import头文件Woman.h和Woman+Secret.h 并创建一个Woman实例对象Rala。随后我们通过.age尝试获取Rala的年龄，然而失败了🌝，无论赋值或是取值，都失败🌝</p><p>Step2 更神奇</p><p>​    随后我们开始怀疑人生，我们尝试在Woman类内部来访问这个age。我们在Woman类内import头文件Woman+Secret.h，然后在init方法中通过.age来访问扩展中的age属性，并将它设置为18岁。一切都完美运行</p><p>Step3 懵逼</p><p>​    😑</p><h2 id="爬坑"><a href="#爬坑" class="headerlink" title="#爬坑"></a>#爬坑</h2><p>​    出现问题以后，我们第一个想到的是Extension的原理 <strong>Extension作为匿名分类，是不是不能加属性？</strong>虽然这与我们对Extension的理解是明显相悖的…Sunny在<a href="http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/" target="_blank" rel="noopener">文章</a>中提到 <strong>Class Extension 在编译期就会将定义的 Ivar、属性、方法等直接合入主类</strong>，所以不同于类别，Extension一定是能够添加属性的，而且是在编译期就完成了。</p><p>​    接下来我们想到了属性的原理，属性其实就是帮我们合成了一个Setter和一个Getter，而在我们这次遇到的问题中，正是方法缺失，所以我们怀疑是合成出了问题。随后我们<strong>将代码还原到Step1的时候的状态</strong>(不要在Woman类中引用Secret扩展)，即一个干净的类且仅在viewController中有操作。然后我们利用Runtime的特性，在viewController中打印了Woman的方法列表</p><pre><code>ExtensionDemo[31872:7177170] method-&gt;.cxx_destructExtensionDemo[31872:7177170] method-&gt;name</code></pre><p>​    果然，并没有合成age相关的方法。我们将代码恢复到Step2的状态，并再次打印了方法列表</p><pre><code>ExtensionDemo[31930:7186671] method-&gt;.cxx_destructExtensionDemo[31930:7186671] method-&gt;nameExtensionDemo[31930:7186671] method-&gt;setAge:ExtensionDemo[31930:7186671] method-&gt;age</code></pre><p>​    不出所料，当我们在Woman类内部需要使用age的时候，系统合成了相关的访问方法。</p><p>​    我们不经意间又进行了一步操作，注释掉Woman类内对age的访问和赋值，并再次打印方法列表，这一次居然得到了跟上述log一模一样的结果——合成了age相关的访问方法。而这与上一步的区别仅是Woman类中import了头文件Woman+Secret.h且并无实际使用。</p><p>​    至此，我们得出了结论</p><p>​    <strong>当我们使用Extension时，尤其是在Extension作为独立文件的时候，如果Extension添加了属性，并且希望它被合成，则需要在主类中引入Extension的头文件</strong></p><p>​    在<a href="https://github.com/panyfun/BlogDemo/tree/master/20180515_ExtensionDemo" target="_blank" rel="noopener">Demo</a>中，我们将正确的用法写在了Man中，毕竟男士的年龄是可以访问的(手动滑稽)</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>Extension中究竟能否添加属性？</p><p>当然可以加，但是加了不一定能用，属性合成依赖于在主类中import扩展的头文件(不在内部使用也要import)</p></li><li><p>能否给系统类添加扩展并添加属性？</p><p>当然不能，因为我们没法在系统类的主类中去import一个头文件</p></li><li><p>关于编译期的逻辑的猜测</p><p>编译器会优先处理主类，然后处理主类的import，如果遇到扩展，就将扩展中的 Ivar、属性、方法等直接合入主类，并对属性进行访问方法合成</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约1200字，将会介绍访问扩展Extension中属性时遇到unrecognized selector的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="专业填坑" scheme="http://pany.fun/categories/%E4%B8%93%E4%B8%9A%E5%A1%AB%E5%9D%91/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>isKindOf与isMemberOf的原理</title>
    <link href="http://pany.fun/post/isKindOf%E4%B8%8EisMemberOf%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://pany.fun/post/isKindOf与isMemberOf的原理/</id>
    <published>2018-05-10T07:01:51.000Z</published>
    <updated>2018-10-18T07:59:46.410Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约1000字，将会讲述自己关于isKindOf与isMemberOf的原理方面的思考</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><h2 id="是什么"><a href="#是什么" class="headerlink" title="# 是什么"></a># 是什么</h2><p>面对新的东西，我们第一个思考的问题往往都是——它是什么。</p><p>虽然 isKindOf 与 isMemberOf 对于我们来说已经是万分熟悉了，但我们依旧希望 系统而形式 的先来认识它们是什么。</p><pre><code>// NSObject.h -&gt; line: 30@protocol NSObject- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;</code></pre><p>这里首先我们需要注意到，它们是定义在 NSObject协议 中的方法，而不是定义在 NSObject类 中的方法，虽然NSObject类默认实现了它们。</p><p>官方文档对于二者的描述</p><blockquote><ul><li>isKindOfClass:</li></ul><p>Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.</p><p>​    返回对于 接收者是否是所给类或者所给类的子类的实例 的判断结果</p><ul><li>isMemberOfClass:</li></ul><p>Returns a Boolean value that indicates whether the receiver is an instance of a given class.</p><p>​    返回对于 接收者是否是所给类的实例 的判断结果</p></blockquote><p>两个方法异同点如下</p><ul><li>都能够判断 接收者是否是所给类本身的实例</li><li>isKindOfClass还能够判断接收者是否是所给类的子类的实例，而isMemberOfClass不能</li></ul><p>以上内容相对简单，网上搜一搜能找到很多，此文不再多说。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="# 为什么"></a># 为什么</h2><p>我们的第二个问题——为什么，我们面对新事物往往也会有这样的好奇。</p><p>为什么 isKindOfClass 能够进行是否属于子类实例的判断？而isMemberOfClass不能？它们做了什么不一样的事情？</p><p>当然，两个不同方法是开发工作的需要，但是这不是我们所想给出的答案，我们更多想知道的是它们是如何去判断的，在判断上又有什么不同。</p><h2 id="答案"><a href="#答案" class="headerlink" title="# 答案"></a># 答案</h2><p>为了理解它们的原理，我们需要先引入一张熟悉的图，如果这张图你不熟悉，请<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" target="_blank" rel="noopener">点击这里</a> 或者google</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-5-10/10683033.jpg" alt="对象，类与元类之间的关系"></p><blockquote><p>图中Root Class(class)可以理解为NSObject，Root Class(meta)可以理解为NSObject meta</p><p><a href="https://developer.apple.com/documentation/objectivec/nsobject" target="_blank" rel="noopener">更精准的描述</a>  NSObject: The root class of <strong>most</strong> Objective-C class hierarchies</p></blockquote><p>isMemberOf 与 isKindOf的判断逻辑，就藏身于这张图中。</p><ul><li><p>isMemberOf:</p><p>step1: 找到 isa 指针所指类</p><p>step2: 判断 isa所指类 与 所给类 是否相同</p></li><li><p>isKindOf:</p><p>step1: 找到 isa 指针所指类</p><p>step2: 判断 isa所指类 与 所给类 是否相同，若不相同 则延该类的继承链(实线)不断向上查询直至nil</p></li></ul><p>两个方法的第一步都是相同的，差别只是在第二步，因为isKindOf多了对于子类的实例的判断，所以也就需要增加继承链的查询。</p><h2 id="源码"><a href="#源码" class="headerlink" title="# 源码"></a># 源码</h2><p>同时因为runtime是开源的，所以我们也可以去查看<a href="https://github.com/opensource-apple/objc4/blob/master/runtime/NSObject.mm" target="_blank" rel="noopener">NSObject源码</a>看是不是这么回事</p><ul><li><p>isMemberOf  <a href="https://github.com/opensource-apple/objc4/blob/cd5e62a5597ea7a31dccef089317abb3a661c154/runtime/NSObject.mm#L1912" target="_blank" rel="noopener">源码</a></p><pre><code class="objective-c">- (BOOL)isMemberOfClass:(Class)cls {    return [self class] == cls;}</code></pre></li><li><p>isKindOf  <a href="https://github.com/opensource-apple/objc4/blob/cd5e62a5597ea7a31dccef089317abb3a661c154/runtime/NSObject.mm#L1923" target="_blank" rel="noopener">源码</a></p><pre><code class="objective-c">- (BOOL)isKindOfClass:(Class)cls {    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) {        if (tcls == cls) return YES;    }    return NO;}</code></pre></li></ul><p>  对比可以发现，isKindOf确实相较isMemberOf多了一个循环，也就是延继承链的查询</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="# 扩展"></a># 扩展</h2><p>在孙源的一篇 <a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="noopener">神经病院objc runtime入院考试</a> 中有这么一道题目，我们一起以上述原理来看看</p><p>(这里为了方便表述，交换了一下几个题目的顺序)</p><pre><code>BOOL res1 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];  // 原孙源博客中res2BOOL res2 = [(id)[NSObject class] isKindOfClass:[NSObject class]];    // 原孙源博客中res1BOOL res3 = [(id)[Sark class] isMemberOfClass:[Sark class]];    // 原孙源博客中res4BOOL res4 = [(id)[Sark class] isKindOfClass:[Sark class]];    // 原孙源博客中res3</code></pre><ul><li><p>Round 1</p><p>接收者为 NSObject ，即图中的 下标A处。取isa，指向 下标B处，并不是NSObject，所以结果为 NO</p></li><li><p>Round 2</p><p>在round 1的基础上继续，已经取到了isa指向 下标B处 且isMemeberOf结果为NO，判断isKindOf接下来需要走继承链，延B的实线走，来到了A处，即NSObject，等于所给类NSObject，所以结果为 YES</p></li><li><p>Round 3</p><p>接收者为 Sark，可以理解为一个继承自NSObject的类，即图中 C 处。取isa指针，指向D，并不是所给的NSObject类，所以结果为NO</p></li><li><p>Round 4</p><p>在round 3的基础上，继续沿D的实线继承链走，经过B、A最终走向nil，始终没有找到所给的Sark类，所以结果为NO</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约1000字，将会讲述自己关于isKindOf与isMemberOf的原理方面的思考&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://pany.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>发掘YYModel逻辑</title>
    <link href="http://pany.fun/post/%E5%8F%91%E6%8E%98YYModel%E9%80%BB%E8%BE%91/"/>
    <id>http://pany.fun/post/发掘YYModel逻辑/</id>
    <published>2018-04-18T07:45:33.000Z</published>
    <updated>2018-09-21T01:55:16.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约3800字，将会在 <a href="https://lision.me" target="_blank" rel="noopener">Lision</a> 的两篇关于YYModel解析的优秀文章的基础上，讲述一些 <a href="https://lision.me" target="_blank" rel="noopener">Lision</a> 没有提到的逻辑细节。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p>首先两篇 <a href="https://lision.me" target="_blank" rel="noopener">Lision</a> 的文章如下，建议有兴趣的朋友先行阅读再回到本文。当然，如果没有用过YYModel，建议先行对 <a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel的基本使用</a> 进行了解。</p><ul><li><p><a href="https://lision.me/yymodel_x01/" target="_blank" rel="noopener">揭秘YYModel魔法（上）</a></p><blockquote><p>主要涉及一些对YYModel的基本介绍，如框架结构、各个文件的介绍、简单代码细节的剖析 以及 YYModel用到的一些技术(主要是runtime)的基本原理 等</p></blockquote></li><li><p><a href="https://lision.me/yymodel_x02/" target="_blank" rel="noopener">揭秘YYModel魔法（下）</a></p><blockquote><p>详细介绍YYModel的 model-&gt;json 以及 json-&gt;model的代码逻辑，但是也有一些因篇幅而不得不忽略的点。</p></blockquote></li></ul><p>本文讲述的就是自己在阅读上述两篇文章的过程中，对于作者迫于篇幅而舍弃或忽略的逻辑细节的理解(有一些细节真的很头大)，作者已经讲述的内容将不再赘述。</p><p>为了方便表述，文中将用来给model赋值的json / dic 都描述为了json。但是其实它们是有一定区别的，例如dic可能是客户端生成的，其中的某些value已经是对象类型了，在转换过程中就不需要再进行隐式类型转换。</p><h2 id="2个类"><a href="#2个类" class="headerlink" title="#2个类"></a>#2个类</h2><h3 id="YYModelMeta"><a href="#YYModelMeta" class="headerlink" title="_YYModelMeta"></a>_YYModelMeta</h3><blockquote><p>NSObject+YYModel.m   -&gt;   line：454</p><p>用于记录 类信息 以及 类的属性映射分类</p></blockquote><pre><code>// NSObject+YYModel.m -&gt; line：454// 为了方便理解，删除了部分无关内容// A class info in object model.@interface _YYModelMeta : NSObject {    @package    YYClassInfo *_classInfo;    NSDictionary *_mapper;        //&lt;NSString *, _YYModelPropertyMeta *&gt;    NSArray *_allPropertyMetas;        //&lt;_YYModelPropertyMeta *&gt;    NSArray *_keyPathPropertyMetas;        //&lt;_YYModelPropertyMeta *&gt;    NSArray *_multiKeysPropertyMetas;    //&lt;_YYModelPropertyMeta *&gt;    NSUInteger _keyMappedCount;}</code></pre><ul><li><p>NSArray *_allPropertyMetas</p><p>容器类型<code>&lt;_YYModelPropertyMeta *&gt;</code>，存放该类所有的属性的信息。</p></li><li><p>NSDictionary *_mapper</p><p>容器类型<code>&lt;NSString *， _YYModelPropertyMeta *&gt;</code>，存放所有的映射关系，并且是以json中的key作为这个mapper的key，方便后面json-&gt;model取用。</p><p> YYModel中映射关系我们大致可以分成几类，分类可以从两种角度(映射的层级数、映射关系的数量)考虑，每种角度下都可以将映射分为两类，我们直接列出来，但是注意 1or2 与 3or4 只是不同的分类角度，它们是可以叠加产生诸如 2&amp;3 的关系的。</p><blockquote><ol><li><p>一级映射</p><p>形如 (json)name -&gt; (model)name 或是 (json)name-&gt;(model)userName 通过一层关系就能取到值的映射（我们姑且称它为一级映射…），这里无关于model中的属性名与json中的key名是否相同，之和映射的层级数有关</p></li><li><p>多级映射</p><p>形如 (json)user.name -&gt; (model)name 的映射就是多级映射，它需要在json中通过多层关系才能取到值</p></li><li><p>单关系映射</p><p>model中的一个属性，在json中有且只有一个key与之相映射（我们姑且称这种为单关系映射…）</p></li><li><p>多关系映射</p><p>model中的一个属性，在json中有多个key与之相映射，例如(json)Id/ID -&gt; (model)usrId。这种映射用于一个model在多处使用的时候，可能需要从不同的json转换而来。</p></li></ol></blockquote></li><li><p>NSArray *_keyPathPropertyMetas</p><p>容器类型<code>&lt;_YYModelPropertyMeta *&gt;</code>，用于存放该类的多级映射属性( 形如 (json)user.name -&gt; (model)name )。</p><p>源码中有这么一段能帮助我们理解这个数组容器存放的内容</p><pre><code>// NSObject+YYModel.m -&gt; line: 551// 为了方便理解，删除了部分无关内容// 取用户自行定义的的映射关系字典做以下处理// 外部传入的参数// NSString *propertyName, NSString *mappedToKey;_YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];if ([mappedToKey isKindOfClass:[NSString class]]) {    if (mappedToKey.length == 0) return;    propertyMeta-&gt;_mappedToKey = mappedToKey;    NSArray *keyPath = [mappedToKey componentsSeparatedByString:@&quot;.&quot;];    for (NSString *onePath in keyPath) {      if (onePath.length == 0) {          NSMutableArray *tmp = keyPath.mutableCopy;          [tmp removeObject:@&quot;&quot;];          keyPath = tmp;          break;      }    }    if (keyPath.count &gt; 1) {    // 当keyPath是多级映射(count&gt;1)的时候加入到keyPathPropertyMetas中，否则直接加入mapper，并以json中的key作为mapper的key      propertyMeta-&gt;_mappedToKeyPath = keyPath;      [keyPathPropertyMetas addObject:propertyMeta];    }    propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;    // 暂时不用关注    mapper[mappedToKey] = propertyMeta;    ...}</code></pre></li><li><p>NSArray *_multiKeysPropertyMetas</p><p>容器类型<code>&lt;_YYModelPropertyMeta *&gt;</code>，用于存放该类的多关系映射属性( 形如 (json)Id/ID -&gt; (model)usrId )。</p><p>源码中也有一段代码能够帮助我们理解这个数组容器存放的内容</p><pre><code>// NSObject+YYModel.m -&gt; line: 576// 为了方便理解，删除了部分无关内容// 取用户自行定义的的映射关系字典做以下处理// 外部传入的参数// NSString *propertyName, NSString *mappedToKey;if ([mappedToKey isKindOfClass:[NSArray class]]) {    NSMutableArray *mappedToKeyArray = [NSMutableArray new];    // mappedToKeyArray中会存放两种格式的东西    // 如果映射是一级映射，则直接存放keyPath字符串    // 如果映射是多级映射，则存放keyPath拆分后数组    for (NSString *oneKey in ((NSArray *)mappedToKey)) {        if (![oneKey isKindOfClass:[NSString class]]) continue;        if (oneKey.length == 0) continue;        NSArray *keyPath = [oneKey componentsSeparatedByString:@&quot;.&quot;];        if (keyPath.count &gt; 1) {          [mappedToKeyArray addObject:keyPath];        } else {          [mappedToKeyArray addObject:oneKey];        }        if (!propertyMeta-&gt;_mappedToKey) {          propertyMeta-&gt;_mappedToKey = oneKey;          propertyMeta-&gt;_mappedToKeyPath = keyPath.count &gt; 1 ? keyPath : nil;        }    }    if (!propertyMeta-&gt;_mappedToKey) return;    propertyMeta-&gt;_mappedToKeyArray = mappedToKeyArray;    [multiKeysPropertyMetas addObject:propertyMeta];    // 经过校验后，如果该属性的mappedToKey有效，则加入到multiKeysPropertyMetas    propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;    // 暂时不用关注    mapper[mappedToKey] = propertyMeta;}</code></pre></li><li><p>NSUInteger _keyMappedCount</p><p>用于记录映射的总数量。YYModel的注释和 Lision 都描述为 “等同于 _mapper.count”。源码中发现，他们确实描述的非常精准，真的只是“等同”而已…因为它并不是直接取的mapper的count，而是取的allPropertyMetas的数量(虽然不明白其中道理)。</p><pre><code>// NSObject+YYModel.m -&gt; line: 617_keyMappedCount = _allPropertyMetas.count;</code></pre></li></ul><h4 id="gt-你可能会有的疑问"><a href="#gt-你可能会有的疑问" class="headerlink" title="&gt; 你可能会有的疑问"></a>&gt; 你可能会有的疑问</h4><p>看完这么几个比较重要的属性以后，你或许注意到了这么两行代码</p><pre><code>propertyMeta-&gt;_next = mapper[mappedToKey] ?: nil;mapper[mappedToKey] = propertyMeta;</code></pre><p>先看第二行，无论哪种映射条件下，propertyMeta都会被加入总映射表mapper。mapper是字典类型，key是json中的key，value是propertyMeta。</p><p>“我们是不是考虑漏了一种情况？如果json中的一个key被多个属性映射了怎么办(比如 (json)name -&gt; (model)sthName， (json)name -&gt; (model)Id)？毕竟mapper是个直接放propertyMeta的字典，多次向字典内添加具有相同key的内容会覆盖的吧？🤔🤔🤔”</p><p>这种情况当然也是有的，但是不要慌张，YYModel已经处理好保证不会覆盖啦😉，第一行代码就是YYModel对这种情况的处理：</p><p>如果要映射的key在mapper中已经存在了(直接设置会覆盖)，YYModel会通过自己构造一个链表的方式，将相同映射key的属性链接起来，propertyMeta-&gt;_next指向另一个属性，这样就能够保证每个属性都不掉队啦。</p><h3 id="YYModelPropertyMeta"><a href="#YYModelPropertyMeta" class="headerlink" title="_YYModelPropertyMeta"></a>_YYModelPropertyMeta</h3><blockquote><p>NSObject+YYModel.m   -&gt;   line：320</p><p>用于记录 属性的信息 以及 属性的映射关系 等</p></blockquote><p>这个类需要注意的点不多，简单了解一下几个东西就行</p><pre><code>// NSObject+YYModel.m -&gt; line：320// 为了方便理解，删除了部分与讲解无关的内容@interface _YYModelPropertyMeta : NSObject {    @package    ...    Class _cls;    // 属性所属的类    Class _genericCls;    // 属性如果是容器(如NSArray)，容器内装的类型       NSString *_mappedToKey;    NSArray *_mappedToKeyPath;    NSArray *_mappedToKeyArray;    ...    _YYModelPropertyMeta *_next;}</code></pre><ul><li><p>Class _genericCls</p><p>需要和_cls区分一下，这个参数只有当属性是容器(如NSArray， NSDictionary)，则用这个参数记录容器内装的对象所属类，简单来说，就是容器的泛型类。</p></li><li><p>NSString *_mappedToKey</p><p>如果属性与json是单关系的一级映射( 形如 (json)name-&gt;(model)userName )，则用此参数记录该属性映射到json中的key</p></li><li><p>NSArray *_mappedToKeyPath</p><p>如果属性与json是单关系的多级映射( 形如 (json)user.name -&gt; (model)name )，则用此参数记录该属性映射到json中的path，以’.’分解后的有效数组</p></li><li><p>NSArray *_mappedToKeyArray</p><p>如果属性与json是多关系映射，则记录到这个数组中，这个数组中既可以放一级映射的NSString，也可以放多级映射以’.’分解后的有效数组</p></li><li><p>YYModelPropertyMeta *next</p><p>当有多个属性映射到同一个json中的key的时候，用这个next将它们以链表的形式连起来</p><p>​</p></li></ul><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="#核心方法"></a>#核心方法</h2><h3 id="BOOL-yy-modelSetWithDictionary-NSDictionary-dic"><a href="#BOOL-yy-modelSetWithDictionary-NSDictionary-dic" class="headerlink" title="- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic"></a>- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic</h3><blockquote><p>NSObject+YYModel.m   -&gt;   line：1478</p><p>YYModel的核心方法之一，也是json/dic转model的主流程入口之一</p></blockquote><p>这个方法 Lision 的原文中也花了一些篇幅来讲，但是有些细节我们还是可以再拿出来说的更明白的。</p><pre><code>// NSObject+YYModel.m -&gt; line: 1497// 为了方便理解，删除了部分与讲解无关的内容- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic {    ...    ModelSetContext context = {0};    context.modelMeta = (__bridge void *)(modelMeta);    context.model = (__bridge void *)(self);    context.dictionary = (__bridge void *)(dic);    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) {        // Operation 1        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);        // Operation 2        if (modelMeta-&gt;_keyPathPropertyMetas) {            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),                                 ModelSetWithPropertyMetaArrayFunction,                                 &amp;context);        }        // Operation 3        if (modelMeta-&gt;_multiKeysPropertyMetas) {            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),                                 ModelSetWithPropertyMetaArrayFunction,                                 &amp;context);        }    } else {        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),                             ModelSetWithPropertyMetaArrayFunction,                             &amp;context);    }}</code></pre><ul><li><p>条件判断</p><p>这个方法不长，占比较多的是一个条件判断。<code>modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)</code>这是一个略微有点古怪的判断，但是其实作者的目很简单——通过判断找到数量比较少的容器开始遍历赋值，以Function执行的次数，加快模型转换速度。</p><p>这个条件翻译一下是这样的</p><p>当model中的属性，多于或等于dic中的键值对数量时，使用较少的一方，即dic，进行遍历并往model中赋值。大多数情况我们的model的属性数量会与dic中的键值对数量相同或略多。</p><p>当model中的属性，少于dic中的键值对数量时，使用较少的一方，即model的属性表，进行遍历并往model中赋值。当json中有无用信息的时候，会出现这种情况。</p></li><li><p>Operation 1 :    对 dic 遍历执行 ModelSetWithDictionaryFunction 方法</p><p>如果只看到这里，按正常理解，如果dic记录了所有的键值对，那么对它进行遍历应当就已经可以完成赋值工作啦，不需要再有多余的操作啦。但是我们却显然看到这一行代码后仍有其它操作。</p><p>而事实上，确实Operation 1能够支撑大部分的业务场景，Lision原文也很准确的将它描述为 <code>一般情况下就是靠 ModelSetWithDictionaryFunction 通过字典设置模型</code>。既然都已经谈到了”一般”，自然我们会有不一般的情况，这些情况归类起来就是我们前面谈到的 <strong>‘多级映射’</strong> 以及 <strong>‘多关系映射’</strong></p><p>因为dic是json转换来的字典，通过ModelSetWithDictionaryFunction的代码(后面会详谈) 我们也能够看到，它实际上就是一个dic遍历的回调函数，会取出key和value进行后续赋值操作，而dic的key显然一般不会直接存在”user.name”这种情况，所以<strong>对dic的遍历只能够完成一级单关系映射</strong>。</p></li><li><p>Operation 2 :   对 _keyPathPropertyMetas 遍历执行 ModelSetWithPropertyMetaArrayFunction 方法</p><p>经过对Operation 1 以及对 _keyPathPropertyMetas 的讲解，这一步应该就已经好理解了，它的目的就是完成Operation 1 完成不了的操作之一——对 多级简单映射 进行处理并赋值。具体的ModelSetWithPropertyMetaArrayFunction我们后面再谈。</p></li><li><p>Operation 3:  对 _multiKeysPropertyMetas 遍历执行 ModelSetWithPropertyMetaArrayFunction 方法</p><p>这一操作逻辑同 Operation 2 ，用于完成对 多关系映射 的处理并赋值。</p></li></ul><h3 id="static-void-ModelSetWithDictionaryFunction-const-void-key-const-void-value-void-context"><a href="#static-void-ModelSetWithDictionaryFunction-const-void-key-const-void-value-void-context" class="headerlink" title="static void ModelSetWithDictionaryFunction(const void key, const void value, void *context)"></a>static void ModelSetWithDictionaryFunction(const void <em>key, const void </em>value, void *context)</h3><blockquote><p>NSObject+YYModel.m  -&gt;  line：1115</p><p>用于完成对 一级单关系映射 的转换处理，以及对映射到同一个key的属性的转换处理。</p></blockquote><pre><code>static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) {    ModelSetContext *context = _context;    __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)];    __unsafe_unretained id model = (__bridge id)(context-&gt;model);    while (propertyMeta) {        if (propertyMeta-&gt;_setter) {            ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta);        }        propertyMeta = propertyMeta-&gt;_next;    };}</code></pre><p>这一段代码相对简单，其中的while循环主要是用来完成对 映射到同一个dic中的key的属性构成的链表进行遍历赋值。其中的赋值方法 ModelSetValueForProperty 会在后面讲述。</p><h3 id="static-void-ModelSetWithPropertyMetaArrayFunction-const-void-propertyMeta-void-context"><a href="#static-void-ModelSetWithPropertyMetaArrayFunction-const-void-propertyMeta-void-context" class="headerlink" title="static void ModelSetWithPropertyMetaArrayFunction(const void _propertyMeta, void _context)"></a>static void ModelSetWithPropertyMetaArrayFunction(const void <em>_propertyMeta, void </em>_context)</h3><blockquote><p>NSObject+YYModel.m  -&gt;  line：1115</p><p>用于完成对 多级映射 以及 多关系映射 的转换处理。</p></blockquote><p>这个方法是 Lision 没有具体讲到的一个方法，貌似是被误看成了 ModelSetWithDictionaryFunction ，虽然功能上也差不多…</p><pre><code>static void ModelSetWithPropertyMetaArrayFunction(const void *_propertyMeta, void *_context) {    ModelSetContext *context = _context;    __unsafe_unretained NSDictionary *dictionary = (__bridge NSDictionary *)(context-&gt;dictionary);    __unsafe_unretained _YYModelPropertyMeta *propertyMeta = (__bridge _YYModelPropertyMeta *)(_propertyMeta);    if (!propertyMeta-&gt;_setter) return;    id value = nil;    if (propertyMeta-&gt;_mappedToKeyArray) {        value = YYValueForMultiKeys(dictionary, propertyMeta-&gt;_mappedToKeyArray);    } else if (propertyMeta-&gt;_mappedToKeyPath) {        value = YYValueForKeyPath(dictionary, propertyMeta-&gt;_mappedToKeyPath);    } else {        value = [dictionary objectForKey:propertyMeta-&gt;_mappedToKey];    }    if (value) {        __unsafe_unretained id model = (__bridge id)(context-&gt;model);        ModelSetValueForProperty(model, value, propertyMeta);    }}</code></pre><p>这一段代码也是相对简单的，主要也就是中间部分的条件判断，但是有了前面对mappedToKeyArray和mappedToKeyPath的解释铺垫也就好理解了。</p><p>YYValueForMultiKeys 和 YYValueForKeyPath 都是一个简单的对dic 循环or递归 取值的方法，相对简单不细讲啦，可以参看YYModel源码。</p><h3 id="static-void-ModelSetValueForProperty-id-model-id-value-YYModelPropertyMeta-meta"><a href="#static-void-ModelSetValueForProperty-id-model-id-value-YYModelPropertyMeta-meta" class="headerlink" title="static void ModelSetValueForProperty(id model,  id value,  YYModelPropertyMeta *meta)"></a>static void ModelSetValueForProperty(id model,  id value,  YYModelPropertyMeta *meta)</h3><blockquote><p>NSObject+YYModel.m  -&gt;  line：784</p><p>用于完成 对属性赋值的工作，也包含一些附加工作，例如 自动类型转换、容器内类型处理</p><p>为了让标题不太长，删除了部分信息，完成的方法名参考源码</p></blockquote><p>这个方法非常非常的长，784行 -&gt; 1099行，但是其中大多是一些类型判断以进行对应处理，建议大家还是多花些时间细细看看源码。</p><p>这里需要提到的关于自动转换，YYModel还是存在一些不足的</p><ul><li><p>容器内的自动类型转换无法完成。从源码我们能看出，这一块是空白的，没有做相关的处理</p><p>当我们的model的某个容器属性 如NSArray里放的是NSDate / NSNumber 时，无法自动类型转换。</p><p>虽然我们额外处理一下也能完成需求，但是欠缺总是种遗憾。PS：不要问我为什么会有这种需求…</p></li><li><p>对于CGSize / CGRect 等基本的系统结构体，无法完成 标准字符串 到 结构体的自动类型转换</p><p>这导致当我们的model中存在如CGSize / CGRect 等属性时，赋值有那么一些原始和乏味 (完成需求是没问题的) 。虽然这是因为runtime无法区分结构体的具体类型…<br>但是个人觉得，还是有办法支持的，例如由业务层返回类型。对于 无统一明确格式规则的字符串 转 CGSize / CGRect 可以不提供自动支持，但是标准格式的字符串还是可以提供支持的，毕竟 CGSize / CGRect 系统也提供了对应的字符串转换方法。</p></li><li><p>针对以上问题，后期计划fork一份YYModel，并自己尝试解决 🌝🌝</p></li></ul><p>其它东西 Lision 的文章里都讲得很好啦~不再赘述</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约3800字，将会在 &lt;a href=&quot;https://lision.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt; 的两篇关于YYModel解析的优秀文章的基础上，讲述一些 &lt;a href=&quot;https://lision.me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lision&lt;/a&gt; 没有提到的逻辑细节。&lt;/p&gt;
    
    </summary>
    
      <category term="开源共勉" scheme="http://pany.fun/categories/%E5%BC%80%E6%BA%90%E5%85%B1%E5%8B%89/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
      <category term="YYModel" scheme="http://pany.fun/tags/YYModel/"/>
    
  </entry>
  
  <entry>
    <title>PZPageListContainer使用手册</title>
    <link href="http://pany.fun/post/PZPageListContainer%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://pany.fun/post/PZPageListContainer使用手册/</id>
    <published>2018-03-28T03:08:04.000Z</published>
    <updated>2018-09-21T01:55:16.895Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约1300字，将会讲述PZPageListContainerView的一些用法。</p><p>PZPageListContainerView是一个能够支持上下左右滑入(类似SnapChat)或纵向/水平滑动(类似头条)的PageList基础框架。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><h2 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h2><p>PZPageListContainerView能够支持多方向的页面滑动，但是只是简单框架，没有一些为具体业务服务的功能。</p><p>这里简单实现两个基本结构以作示例  <a href="https://github.com/panyfun/PZPageListContainerView" target="_blank" rel="noopener">源码</a></p><ul><li><p>类似SnapChat首页的多方向滑入</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-28/27022081.jpg" alt="SnapChat风格"></p></li><li><p>类似头条的横向多页面滑动</p></li></ul><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-28/85028526.jpg" alt="头条风格"></p><h2 id="接入"><a href="#接入" class="headerlink" title="#接入"></a>#接入</h2><p>接入的方式有主要有两种</p><ul><li>直接使用<strong>PZPageContainerView</strong></li><li>使用<strong>PZPageListContainerViewController</strong></li></ul><p>PZPageListContainerViewController是对PZPageContainerView的Controller化包装，它为PZPageContainerView添加了一些Controller才有的特性，例如viewWillAppear等生命周期方法。</p><p>核心部分两者并无区别。</p><p>接入以后，两个方向的列表其实就已经都具有了，接下来就是通过相关的属性、方法、协议等来控制。</p><h2 id="属性与方法解析"><a href="#属性与方法解析" class="headerlink" title="#属性与方法解析"></a>#属性与方法解析</h2><h4 id="属性部分"><a href="#属性部分" class="headerlink" title="属性部分"></a>属性部分</h4><pre><code>@property (nonatomic, weak) id&lt;PZPageListContainerViewDataSource&gt; dataSource; /**&lt; 建议先设置数据源，避免一些异常 */@property (nonatomic, weak) id&lt;PZPageListContainerViewDelegate&gt; delegate;</code></pre><p>数据源和代理，这两个参数相对简单，数据源方法有两个必须实现，代理全为可选</p><pre><code>@property (nonatomic, strong) __kindof UIViewController&lt;PZPageListPageContentProtocol&gt; *backgroundVC;@property (nonatomic, strong) UIView *headerView;@property (nonatomic) BOOL autoAdjustPageFitHeader;</code></pre><p>headerView：如 头条效果中的灰色顶部。需要外部设置一个view。</p><p>autoAdjustPageFitHeader：当存在headerView时是否调整页面上其它部分的frame，默认是YES，如果设置为NO的话，需要自己在外部去处理如inset等。</p><p>backgroundVC：如 SnapChat风格中间白色固定的部分，它是一个单独的VC，独立于内部的collectionView之外。因为需要处理collectionView的滑动手势，这个vc不得已必须由外部传入，然后由内部插入到PZPageContainerView的subview中index为0的位置。</p><pre><code>// 如果只是单项列表，设置无效@property (nonatomic) NSUInteger horizontalScrollableIndex;  /**&lt; default = NSUIntegerMax, 当垂直list处在该index时，水平list可以滑动，NSUIntegerMax表示不限制 */@property (nonatomic) NSUInteger verticalScrollableIndex;    /**&lt; default = NSUIntegerMax, 当水平list处在该index时，垂直list可以滑动，NSUIntegerMax表示不限制 */</code></pre><p>这两个参数是对外的参数里比较难理解的</p><p>他们的主要作用是用来控制横纵列表交叉的时候的问题，比如SnapChat效果中，横纵列表只有在index为1的时候才能切换方向，而在其它页面，比如左右页面的时候，就只能横向滑动，上下页面的时候，就只能纵向滑动。他们是相互交叉限制的(横向限制纵向的滑动，纵向限制横向的滑动)</p><p>横向列表能够滑动的条件是  纵向列表的index == horizontalScrollableIndex</p><p>纵向列表能够滑动的条件是  横向列表的index ==  verticalScrollableIndex</p><h4 id="方法部分"><a href="#方法部分" class="headerlink" title="方法部分"></a>方法部分</h4><p>方法部分整体比较简单，得益于oc的命名风格，方法基本上看名字就知道干什么的</p><pre><code>- (void)reloadData;- (void)enableScroll:(BOOL)enable inDirection:(PZPageListDirection)direction;- (void)scrollToIndex:(NSUInteger)index inDirection:(PZPageListDirection)direction animated:(BOOL)animated;- (__kindof UIViewController&lt;PZPageListPageContentProtocol&gt; *)viewControllerAtIndex:(NSUInteger)index inDirection:(PZPageListDirection)direction;- (__kindof UIViewController&lt;PZPageListPageContentProtocol&gt; *)currentVisibleViewController;</code></pre><p>-enableScroll:inDirection: 是用来在有需要的时候限制某个方向的滑动的。比如SnapChat效果中，当我们点击中间白色页面的switch以后，为了让滑块能够滑动，需要把横纵的滑动都先禁掉，用的就是这个方法。</p><p>需要略微注意的是两个返回viewController的方法，需要被加载过以后才能够返回。</p><h2 id="数据源"><a href="#数据源" class="headerlink" title="#数据源"></a>#数据源</h2><pre><code>- (NSInteger)pzPageList:(PZPageListContainerView *)containerView numOfItemsInDirection:(PZPageListDirection)direction;/** @return 需要显示的控制器(请在外部自行保留及添加至子控制器)，支持返回nil用于将该区间留空 */- (UIViewController&lt;PZPageListPageContentProtocol&gt; *)pzPageList:(PZPageListContainerView *)containerView itemForIndex:(NSInteger)index inDirection:(PZPageListDirection)direction;</code></pre><p>-pzPageList:numOfItemsInDirection: 用来返回某方向上page的数量，类似collectionView的numberOfItemsInSection。</p><p>-pzPageList:itemForIndex:inDirection：用来返回某方向上某位置的控制器，类似collectionView的cellForItemAtIndexPath。这里设计成允许返回nil的，因为比如SnapChat效果中，为了把白色页面漏出来，需要在collectionView上留空。</p><h2 id="代理"><a href="#代理" class="headerlink" title="#代理"></a>#代理</h2><p>代理除了常规的几个之外，有一个不常见的</p><pre><code>/* 内部collectionView的gesture的代理，用于解决某些手势冲突 */- (BOOL)pzPageList:(PZPageListContainerView *)containerView gestureRecognizer:(UIGestureRecognizer *)recognizer shouldSimultaneouslyWith:(UIGestureRecognizer *)otherRecognizer;</code></pre><p>这个方法是UICollectionView的panGestureRecognizer的UIGestureRecognizerDelegate中的shouldRecognizeSimultaneouslyWithGestureRecognizer的延伸。</p><pre><code>#pragma mark - &lt;UIGestureRecognizerDelegate&gt;// note: returning YES is guaranteed to allow simultaneous recognition. // returning NO is not guaranteed to prevent simultaneous recognition, // as the other gesture&#39;s delegate may return YES- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;</code></pre><p>内部实现上其实就是collectionView的panGesture的代理方法直接回调了出来，让外部来处理一些手势冲突的问题。但是不用恐慌，这个方法是可选的，内部已经添加了对tableview的默认处理用来兼容tableView的删除手势。</p><h2 id="PZPageListPageContentProtocol"><a href="#PZPageListPageContentProtocol" class="headerlink" title="#PZPageListPageContentProtocol"></a>#PZPageListPageContentProtocol</h2><p>这个协议里目前主要是一套自己的生命周期，因为系统生命周期会乱掉。当UIViewController实现这个协议里的方法的时候，会在合适的时机得到回调。</p><h2 id="其它"><a href="#其它" class="headerlink" title="#其它"></a>#其它</h2><p>开发教程：<a href="https://panyfun.github.io/post/PZPageListContainerView/" target="_blank" rel="noopener">https://panyfun.github.io/post/PZPageListContainerView/</a></p><p>demo：<a href="https://github.com/panyfun/PZPageListContainerView" target="_blank" rel="noopener">https://github.com/panyfun/PZPageListContainerView</a></p><p>欢迎Issues：<a href="https://github.com/panyfun/PZPageListContainerView/issues" target="_blank" rel="noopener">https://github.com/panyfun/PZPageListContainerView/issues</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约1300字，将会讲述PZPageListContainerView的一些用法。&lt;/p&gt;
&lt;p&gt;PZPageListContainerView是一个能够支持上下左右滑入(类似SnapChat)或纵向/水平滑动(类似头条)的PageList基础框架。&lt;/p&gt;
    
    </summary>
    
      <category term="开源共勉" scheme="http://pany.fun/categories/%E5%BC%80%E6%BA%90%E5%85%B1%E5%8B%89/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
      <category term="PZPageListContainer" scheme="http://pany.fun/tags/PZPageListContainer/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记：由NSString *引发的思考</title>
    <link href="http://pany.fun/post/%E7%94%B1NSString*%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://pany.fun/post/由NSString*引发的思考/</id>
    <published>2018-03-24T07:09:54.000Z</published>
    <updated>2018-09-21T01:55:16.897Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约2000字，将会讲述由NSString *引发的关于OC内存模型以及一些语法的简单思考。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><h2 id="缘起"><a href="#缘起" class="headerlink" title="#缘起"></a>#缘起</h2><p>大概两年半前，当我在校招面试的时候，曾经有个面试官问了我这么一个问题</p><p><strong>“能不能这么声明一个字符串变量(NSString str = @”xxx”;)？？会有什么问题？？”</strong></p><p>拿到这个问题的时候我是懵逼的，从我们写第一行OC开始，我们都是这么去声明一个字符串变量的</p><pre><code>NSString *str = @&quot;xxx&quot;;</code></pre><p>这行最最简简单单我们每天都要写无无无无数次的代码，好像还真的没有去质疑过为什么要这么写。我们一直被教育的都是OC里声明一个对象是要带星号的，因为它是一个指针，也因为这是学习OC所需要接受的最基本规则——语法。这就像我们学了几十年数学，1+1=2就是数学里最基本的规则一样，我们也极少去思考1+1=3会怎么样，只因为它是定好的规则。</p><p>所以我的回答是：不能这么声明，因为这是OC当中的语法规则，这么声明会无法编译通过，会报语法错误。(当然我还回答了诸如*str是一个指针，str是对象 巴拉巴拉)</p><p>当时面试官紧追不放，依旧追问为什么语法不允许呢？仿佛在追问我为什么要规定1+1=2。所以很自然的我的面试挂掉啦😇</p><p>回家后我在XCode里敲上了这行代码，当时编译器报出了类似 “哎呀，你看你怎么这么粗心，是不是忘了写星号呀，快让我帮你Fix一下吧” 的错误(当时确实报的这种搞笑错误，但是现在已经不是这么报了)，然后点Fix，就会自动加上星号。当时即使搜索也依旧找不出什么，大多数人都是传授正确用法而不会告诉为什么(毕竟是这么简单的基础语法，猪都能学会而且不会用错。PS:我到现在也不知道为什么一定要1+1=2😅)。</p><p>后来我在一些开发群里分享了我的这次面试经历，很多人都一致认为这个面试官太奇葩，八成不是专门做iOS开发的然后又来面试iOS。然后我也就释然了，只怪运气不好。</p><h2 id="重识"><a href="#重识" class="headerlink" title="#重识"></a>#重识</h2><p>直到今年过年回家的时候，因为高铁上时间太无聊，所以去回顾了一本书——<a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">《Effective Objective-C 2.0》</a></p><p>书的第一章是讲OC的起源的，也顺带稍微提了一下OC的一些语法。可能很多人都会直接跳过这种看着就不正经的章节(毕竟现在太多书都用前面几页来说这本书非常好，堪比圣经，老少咸宜……)，原来初看的时候我还是看了的，但是好像并没记住啥。而这次回顾我却在这些片段里找到了当初面试题的解答。</p><p>书中有这么一段(摘自Effective Objective-C 2.0第1章第1条，页码2…真的是很靠前、很像不正经)</p><blockquote><p>Objective-C语言中的指针是用来指示对象的。想要声明一个变量，令其指代某个对象，可用如下语法:</p><pre><code>NSString *someString = @&quot;The string&quot;;</code></pre><p>这种语法基本上是照搬C语言的，它声明了一个名为someString的变量，其类型是NSString *。也就是说，此变量为指向NSString的指针。所有Objective-C语言的对象都必须这样声明，因为对象所占内存总是分配在“堆空间”(head space)中，而绝不会分配在“栈”(stack)上。不能在栈中分配Objective-C对象：</p><pre><code>NSString stackString;// error：interface type cannot be statically allocated</code></pre></blockquote><p>这也就是前面提到的面试题的答案啦</p><h2 id="解惑"><a href="#解惑" class="headerlink" title="#解惑"></a>#解惑</h2><pre><code>NSString *str = @&quot;xxx&quot;;</code></pre><p>什么是NSString *str ？</p><p>str是一个栈上的变量，它存放的内容是一个内存地址，这个内存地址是一个堆上的地址，这个堆地址上存放了一个字符串@“xxx”(实际上编译器还会做一些处理，把编译期就已经确定的字符串放到常量区，此处主要表达它不会存在栈上)。虽然我们不能在栈上开辟内存用来存放对象数据，但是我们可以在堆上开辟内存用来存放对象数据存，然后在栈上开辟内存用来存放对象的堆内存地址，这个栈上开辟的内存就是我们的指针变量。</p><pre><code>NSString str;</code></pre><p>什么是NSString str ？</p><p>这种声明应该只能称为一种尝试，它并不能真的运行起来。它在尝试声明一个对象，并期望在栈里开辟空间来直接存放。这是不被OC的内存模型规则所允许的(没错，又一个规则👊)。</p><p>还有些再稍微深入一点点的👇👇</p><h2 id="思考"><a href="#思考" class="headerlink" title="#思考"></a>#思考</h2><p>我们更深一步，再来想想另一个问题</p><pre><code>NSString *str1;NSString * str2;NSString* str3;</code></pre><p>是的，你没有眼花，我也没敲错，这3行代码只是星号的位置以及变量名不同而已。首先这3行代码都能编过，毕竟XCode天天报bug也是蛮累的，一些最简单的语法错误干脆就自己默默处理不报啦。</p><p>虽然3行代码都能编(骗)过，但是在<strong>思想上体现出来的东西是完全不一样的</strong>，请记住正确的写法永远只有第一种。</p><p>首先OC是允许我们声明变量并申请开辟内存空间的，但是也加了限制，只允许我们申请在栈上开辟内存空间。因为<strong>栈内存是不需要我们手动来管理</strong>的(就是不需要清理)，它们会在栈帧弹出的时候自动清理，而相反堆内存是需要我们手动管理的。所以加上限制还是很有道理的。</p><blockquote><p>聪明的小伙伴们以及一些入坑不太久的小伙伴估计要提问啦，那堆上内存我们要怎么管理呢？好像开发了这么多年都没管理过啊…这个就又要怪XCode啦，它写了嘛！ARC自动的插入了内存管理相关的代码，这些代码就是管理堆内存的。</p></blockquote><p>那么为什么使用NSString *str这种写法而不使用其它两种呢？我想大概是为了 统一代码要表达的思想。别忘了我们还有一些非对象类型的变量，例如CGFloat f = 1.5; 这行代码表示我们想在栈上开辟一个空间，最终这个空间会给外部一个CGFloat。</p><p>我们的代码中的对象类型的声明，无论是NSString *str，还是NSString str，它们要表达的就是在栈上开辟一个空间，这个空间最终能够给到外部的、我们需要真正关心的，就是一个字符串——NSString。只不过语法允许的是要再经过一次内存地址的转换的，所以带上星号来标明；而不被语法允许的是直接指向的，没有星号。但是我们最主要的诉求，还是NSString，OC并不希望我们去关注更多其它的复杂信息，OC的变量就是一个黑盒，你只需要知道它能给你想要的。这也就跟非对象类型的变量的表达形成了统一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约2000字，将会讲述由NSString *引发的关于OC内存模型以及一些语法的简单思考。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://pany.fun/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>一个支持页面多方向划入的框架--PZPageListContainerView</title>
    <link href="http://pany.fun/post/PZPageListContainerView/"/>
    <id>http://pany.fun/post/PZPageListContainerView/</id>
    <published>2018-03-20T02:59:38.000Z</published>
    <updated>2018-09-21T01:55:16.894Z</updated>
    
    <content type="html"><![CDATA[<p>本文大约5100字，需要的阅读时间比较长，属于教程类，慎入。建议实在空闲或有空且有需求的时候跟着做(虽然一般有需求都不会有空)。直接上手请移步<a href="https://panyfun.github.io/post/PZPageListContainer使用手册/" target="_blank" rel="noopener">使用说明书</a></p><p>本文将会讲述一个能够支持上下左右划入(类似SnapChat)或纵向/水平滑动(类似头条)的PageList框架的搭建过程及其中遇到的一些问题。</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p><strong>本文的相关测试demo</strong>: <a href="https://github.com/panyfun/PZPageListContainerView" target="_blank" rel="noopener">PZPageListContainerViewDemo</a></p><p>测试环境：Xcode9.2、iPhone7模拟器-iOS11.2、iPhone7-11.2.5</p><h2 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h2><p>本文将讲述一个我自己写的containerView的搭建过程以及遇到的一些问题与处理，它来源于我司的一些业务思考。它既能够支持类似SnapChat的上下左右页面划入的功能(并做的更优秀)，同时也能够支持类似今日头条的横向PageList。实际上，横向、纵向、横+纵的PageList它都是没有问题的。</p><p>因为只是想搭建一个易用的框架，所以整体设计不会向太多业务偏移，不会涉及特别细节的业务需求。</p><p>这篇教程之后，我们最终将会实现的效果是这样的</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-28/27022081.jpg" alt="效果图"></p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="#开始搭建"></a>#开始搭建</h2><p>搭建过程我们将以SnapChat的首页为模板进行，更多PZPageListContainerView的用法将会写在文末。</p><p>我们面临的一个问题当然是容器的选型，iOS中能滚动的还是有那么几个的，比如scrollView、tableView、collectionView 还有一个UIPageController(用过一次，感觉挺别扭…)。</p><p>我们最开始是用scrollView实现的，一个足够满足明确需求且足够灵活的选型。但是它在我们写一套单独的生命周期之类的方法的时候(后面将会讲到原因)，在一些边界情况需要写很多的代码来判断，再加上一些其它的动画需求，代码量会更多，所以PZPageListContainerView最终所幸我就选择了collectionview。OK，<strong>容器选型-&gt;UICollectionView</strong>。</p><p>既然我们需要像SnapChat一样支持上下左右的页面都能向中间划入显示，那么必然就需要两个collectionView的，一个collectionView用来承载左和右使用横向layout，另一个用来承载上和下使用纵向layout，两个collectionView都把第二个cell留空并设置clear color。</p><p>那么类似SnapChat中间部分的相机页面放哪呢？观察发现，中间的页面是不会跟随着移动的，所以，这个中间页面一定不会放在我们的collectionView上。因为中间这个视图比较特殊，先不讲复杂，先用一个label代替啦，后面我们会有相关部分来解决。我们前面写collectionView的时候有各留一个cell的空白，就刚好能够把label露出来啦。完成后我们就会得到下面这样的视图结构，这一块代码比较简单，不详述啦，详见源码</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-22/75360384.jpg" alt="初步视图结构"></p><p>完成初步视图结构的搭建后，我们会发现一个问题：两个collectionView相互覆盖，只有一个能够被滑动，另一个没法动…</p><h2 id="问题一：两个collectionView相互覆盖，无法同时滑动"><a href="#问题一：两个collectionView相互覆盖，无法同时滑动" class="headerlink" title="#问题一：两个collectionView相互覆盖，无法同时滑动"></a>#问题一：两个collectionView相互覆盖，无法同时滑动</h2><p>究其原因，其实是两个collectionView因为都是全屏的，所以在层级上，一定有一个在上面一个在下面，因而导致了遮蔽，以至于在下面的没法被滑动。</p><p>但是仔细想想，其实两个collectionView的滑动并没有真正的冲突，它们一个左右滑动，一个上下滑动，按道理应该是可以同时且<strong>同级</strong>存在的，这里需要强调一下同级，指的是在<strong>同一个view上是可以同时存在一个左右手势和一个上下手势的</strong>。</p><p>接着我们找到collectionView的父视图scrollView，然后就会找到这么个属性👇👇</p><pre><code>@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer</code></pre><p>它是readonly的，我们无法修改，但是我们可以拿出来使用</p><p>最终我们通过这么两行代码解决了这个问题</p><pre><code>[self addGestureRecognizer:_horizontalCollectionView.panGestureRecognizer];[self addGestureRecognizer:_verticalCollectionView.panGestureRecognizer];// self 指的PZPageListContainerView，此处它是collectionView的父视图</code></pre><p>然后两个collectionView就都能够顺利滑动啦🎉</p><p>然而，又一个问题来啦，在乱滑一通后，会出现非空cell重叠的情况，就像下面这样</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-22/7074114.jpg" alt=""></p><p>相机画面出现在最底层是没有问题的，有问题的是 绿色(代表上)和橙色(代表左) 的重叠，这个在SnapChat中是不可能重叠的。其实原因很简单，我们的collectionView的手势都被移到了同一层级，所以它们的滑动都是随时可以生效的，而SnapChat的横向list的滑动，只在纵向list处于第二个(即空白cell并露出相机)的时候才可以滑动，纵向list的滑动亦然。</p><p>所以解决办法也很简单，在某些情况下，我们需要限制collectionvView的滑动</p><h2 id="问题二：实现某些情况下的单个collectionView滑动"><a href="#问题二：实现某些情况下的单个collectionView滑动" class="headerlink" title="#问题二：实现某些情况下的单个collectionView滑动"></a>#问题二：实现某些情况下的单个collectionView滑动</h2><p>为了让功能更加灵活，我们首先提供了两个可供外部设置的参数，由业务来决定具体的滑动限制</p><pre><code>// 如果只是单项列表，无需设置@property (nonatomic) NSInteger horizontalScrollableIndex;  /**&lt; default = 0, 当垂直list处在该index时，水平list可以滑动，NSIntegerMax表示不限制 */@property (nonatomic) NSInteger verticalScrollableIndex;    /**&lt; default = 0, 当水平list处在该index时，垂直list可以滑动，NSIntegerMax表示不限制 */</code></pre><p>简单的解释一下这两个参数</p><p>horizontalScrollableIndex：用来表示horizontalList什么时候可以滑动，这个滑动时机用index表示，index指的是另一个方向即verticalList的indexPath中的item。</p><p>当 verticalList的当前显示cell的indexPath的item == horizontalScrollableIndex 时 horizontalList 允许被滑动， 如果 horizontalScrollableIndex == NSIntegerMax 则不做滑动限制。</p><p>verticalScrollableIndex 也是一样的道理。</p><p>代码实现如下：</p><pre><code>#pragma mark - Private- (void)resetCollectionViewScrollable {    NSInteger horizontalIndex = floor(_horizontalCollectionView.contentOffset.x / self.bounds.size.width);    NSInteger verticalIndex = floor(_verticalCollectionView.contentOffset.y / self.bounds.size.height);    _horizontalCollectionView.scrollEnabled = _horizontalScrollableIndex == NSIntegerMax || verticalIndex == _horizontalScrollableIndex;    _verticalCollectionView.scrollEnabled = _verticalScrollableIndex == NSIntegerMax || horizontalIndex == _verticalScrollableIndex;}</code></pre><p>因为在很多地方都会涉及到调用，所以我们这里设计成了私有方法。通过偏移量的向下取整来判断当前的index，然后通过index对比来判断是否允许滑动。</p><p>需要调用的主要地方有下面这几个，其它的具体见源码(Edit: 后期因为需要满足其它功能，源码稍微做了些修改)</p><blockquote><p><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;</code><br><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView;</code></p></blockquote><p>搭配两个滑动限制参数，我们还设计了两个公开方法，用来通过代码把list滑动到对应的位置，其内部实现就是调用的collectionView的scrollToItemAtIndexPath，比较简单不过多阐述。两个滑动限制参数和两个公开的滑动方法需要搭配使用，否则使用不当会导致无法滑动。</p><p>在这里，我们把两个滑动限制参数都设置为1(一共有3个cell，中间的index为1)，并且把横纵两个list都滑动到index为1的地方，然后一个类似SnapChat首页的基础结构就完成啦！🎉🎉</p><blockquote><p>这里再插两句，其实SnapChat只实现了左右两个页面的划入，并没有去做上下的，我也看了他们的视图结构，他们仅在横向上使用的scrollView，纵向上却是使用手势来控制的。虽然不清楚他们这么选择的原因，但是从我司自己实现的效果来看，整体还是很流畅的，感觉体验上尤其上下页面比SnapChat体验更好。</p></blockquote><h2 id="问题三：让hit能够透过collectionView"><a href="#问题三：让hit能够透过collectionView" class="headerlink" title="#问题三：让hit能够透过collectionView"></a>#问题三：让hit能够透过collectionView</h2><p>SnapChat位于中间的页面是一个相机页面，那么在我们前序步骤完成的结构上，如果我们尝试去和这个页面做一些交互，比如我们在label同级加上一个UISwitch，会发现它根本不能响应…</p><p>原因也是非常简单的，因为被collectionView挡住了嘛，点击全被拦住了。所以解决方案当然是尝试然点击能够透过去，这个重写collectionView的hitTest就能做到啦，这也是前面的结构图中我们将collectionView自定义类型的原因。</p><p>一方面因为点击能否透过涉及到一些具体逻辑需要在PZPageListContainerView(两个collectionView的父视图，也是这个框架的根视图)中判断，另一方面因为想将逻辑都统一在一起，所以我们在collectionView的hitTest中直接通过代理把事件转出去了，而整个设计中collectionView的代理正好是PZPageListContainerView。</p><p>代理：</p><pre><code>@protocol PZContainerContentCollectionViewDelegate&lt;UICollectionViewDelegate&gt;@optional- (UIView *)pzContainerCollectionView:(PZContainerContentCollectionView *)collectionView didHitWithInfo:(NSDictionary *)hitInfo;@end</code></pre><p>hitTest重写:</p><pre><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    // 拿到原本的应当响应这个事件的hitView    UIView *hitView = [super hitTest:point withEvent:event];    // 将相关数据传递给delegate    if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(pzContainerCollectionView:didHitWithInfo:)]) {        NSMutableDictionary *hitInfo = [NSMutableDictionary dictionary];        [hitInfo setValue:[NSValue valueWithCGPoint:point] forKey:@&quot;hitPoint&quot;];        [hitInfo setValue:hitView forKey:@&quot;hitView&quot;];        [hitInfo setValue:event forKey:@&quot;hitEvent&quot;];        // 由delegate来决定谁来响应这个hit        UIView *responseView = [self.delegate performSelector:@selector(pzContainerCollectionView:didHitWithInfo:) withObject:self withObject:hitInfo];        hitView = responseView;    }    return hitView;}</code></pre><p>接下来就是在PZPageListContainerView中进行判断，并处理这个代理啦</p><pre><code>#pragma mark - &lt;PZContainerContentCollectionViewDelegate&gt;- (UIView *)pzContainerCollectionView:(PZContainerContentCollectionView *)collectionView didHitWithInfo:(NSDictionary *)hitInfo {    UIView *hitView = [hitInfo valueForKey:@&quot;hitView&quot;];    // 正常情况下，hitView应当是cell的contentView的subview    // 只有当页面存在空白区域的时候，才会点中cell.contentView    // 如果点中的是contentView(superview为cell)，返回nil不响应，其它情况均正常响应    UIView *responseView = [hitView.superview isKindOfClass:[UICollectionViewCell class]] ? nil : hitView;    return responseView;}</code></pre><p>当我们hit的是cell的contentView的时候，说明我们点的cell在这一块位置是空白的，如果cell在这一块位置有其它view，是一定hit不到contentView的，除非也无需求改写了其它view的hitTest，所以hit在这里是应该被允许透过去的。其它区域，hit正常响应。</p><p>理论上，这样子hit就能够透过collectionView啦，但是实际尝试后，我们会发现，switch对于点击仍然是没有反应的。这是一个需要试错然后找到解决方案的问题，它可能是一个无奈之解，所以我们选择在文中提出而不是回避。</p><p>此处将回到我们前面埋下的一个坑——类似SnapChat中间的相机视图，究竟该放在哪里。</p><h2 id="问题四：中间类似相机视图-不需要跟随滚动的视图-的层级问题"><a href="#问题四：中间类似相机视图-不需要跟随滚动的视图-的层级问题" class="headerlink" title="#问题四：中间类似相机视图(不需要跟随滚动的视图)的层级问题"></a>#问题四：中间类似相机视图(不需要跟随滚动的视图)的层级问题</h2><p>我们改写collectionView以后switch仍然无法响应点击，原因是因为hit被我们collectionView的父视图——即PZPageListContainerView拿走啦。</p><p>我们尝试着按老思路，改写PZPageListContainerView的hitTest来做判断，我们做了这样的判断</p><pre><code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {    UIView *hitView = [super hitTest:point withEvent:event];    return hitView == self ? nil : hitView;}</code></pre><p>它能够解决层级在PZPageListContainerView下的switch无法响应的问题，但也带来了另一个问题——PZPageListContainerView中的collectionView无法滑动了。这也算预期之内的问题，因为我们之前为了让collectionView能够同时滚动，把它们的panGesture都挪到了PZPageListContainerView上，而放我们在滑动的时候，hitView原本应当是PZPageListContainerView，但是却被hitTest错误返回nil不响应啦，此方案陷入了无解。</p><p>简单捋顺：collectionView的滑动的panGesture必须在整个页面层级的最后，这里的整个不仅仅包含我们的PZPageListContainerView，还包含跟PZPageListContainerView同层级或有更低层级的其它视图。</p><p>最终，我们选择了这样一个方案(后续有好的方案再提升)</p><p>在PZPageListContainerView中，以懒加载的方式提供一个readOnly的backgroundView，用于方便外部放一些东西，比如我们想要的类似相机的视图。</p><p>此时视图结构是这样的👇👇 蓝色选中的就是提供给外部的backgroundView</p><p><img src="http://p4jcee1r9.bkt.clouddn.com/18-3-22/85966454.jpg" alt="新的视图结构"></p><p>对于这样的设计还有一个好处，哪怕这个backgroundView上有局部的panGesture(比如有个小的collectionView)，也是不冲突的，因为它在我们的collectionView的panGesture之上，所以也能很好的工作。</p><p>解决这个问题以后，一切看起来就更加顺畅啦，仿佛胜利在望。</p><p>接下来我们尝试往四周的页面上加些复杂的东西，比如我们往左侧的页面(橙色)上加一个tableView，并且让tableView支持删除功能。然后问题又来啦…</p><h2 id="问题五：tableView的侧滑删除与pageList的侧滑冲突问题"><a href="#问题五：tableView的侧滑删除与pageList的侧滑冲突问题" class="headerlink" title="#问题五：tableView的侧滑删除与pageList的侧滑冲突问题"></a>#问题五：tableView的侧滑删除与pageList的侧滑冲突问题</h2><p>在我们给左侧页面添加tableView且实现删除功能无误的情况下，滑动删除cell触发的(几乎)总是PZPageListContainerView内的collectionView的滑动。</p><p>这个bug主要还是上下层手势冲突引起的，同时有两个手势可以响应。这里我们用到一个用来控制手势被识别后能否继续沿响应链传递的方法</p><pre><code>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;</code></pre><blockquote><p>这是UIGestureRecognizerDelegate中的方法，它用来控制是否允许多个手势共存，返回NO，则手势被识别后停止传递，返回YES则会继续沿响应链传递。默认返回NO</p></blockquote><p>我们对这个方法的使用是这样的，当手势冲突时，在这个方法中来禁掉一个手势(尽量保证同时只有一个手势响应，不然场面会有点失控🌝)。这个方法的调用是很早的，它在手势收到触碰事件的时候就能够有回调。</p><p>具体代码如下</p><pre><code>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {    if ([otherGestureRecognizer.view isKindOfClass:[UITableView class]] &amp;&amp;        gestureRecognizer.state != UIGestureRecognizerStatePossible) {        if ([otherGestureRecognizer.view isKindOfClass:[UITableView class]] ) { //tableview可能存在滑动删除问题            CGPoint touchPoint = [otherGestureRecognizer locationInView:otherGestureRecognizer.view];            UITableView *tableView = (UITableView *)otherGestureRecognizer.view;            __block BOOL touchCellCanEdit = NO;            [tableView.visibleCells enumerateObjectsUsingBlock:^(__kindof UITableViewCell * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {                if (CGRectContainsPoint(obj.frame, touchPoint)) {                    NSIndexPath *indexPath = [tableView indexPathForCell:obj];                    if ([tableView.dataSource respondsToSelector:@selector(tableView:canEditRowAtIndexPath:)]) {                        touchCellCanEdit = [tableView.dataSource tableView:tableView canEditRowAtIndexPath:indexPath];                    }                    // 系统的tableView的滑动删除还有另一种实现方式，也需要根据情况判断一下                    if (!touchCellCanEdit &amp;&amp; [tableView.delegate respondsToSelector:@selector(tableView:editActionsForRowAtIndexPath:)]) {                        NSArray *actionArr = [tableView.delegate tableView:tableView editActionsForRowAtIndexPath:indexPath];                        touchCellCanEdit = actionArr.count &gt; 0;                    }                    *stop = YES;                }            }];            // 当点中cell且cell能删除的时候，禁用当前collectionView的滑动手势            gestureRecognizer.enabled = !touchCellCanEdit || otherGestureRecognizer.state == UIGestureRecognizerStateEnded || otherGestureRecognizer.state == UIGestureRecognizerStateCancelled;            // 当前滑动手势被禁用，则允许手势继续传递            return !gestureRecognizer.enabled;        }    }    return NO;}</code></pre><p>之所以要做一系列判断，是希望尽量缩小手势冲突的范围，因为cell的删除手势只有一个且在tableView上，所以我们想尽量只在cell支持删除的部分去响应删除，其它部分(如header、没有cell的空白部分)依旧响应collectionView的滑动。</p><p>处理完tableView的手势以后，考虑到其它页面可能同样存在类似的问题，所以我们又提供了代理供业务自行处理。</p><p>这个问题解决以后，cell就能够正常被删除啦，一切又回到了预期的模样。</p><h2 id="问题六：为什么生命周期方法执行时间点不对"><a href="#问题六：为什么生命周期方法执行时间点不对" class="headerlink" title="#问题六：为什么生命周期方法执行时间点不对"></a>#问题六：为什么生命周期方法执行时间点不对</h2><p>完成上述步骤以后，如果我们尝试去在上下左右的controller中的系统的生命周期方法(例如：-viewWillAppear)中去做些什么，会发现这些方法都被很早就执行啦，几乎是PZPageListContainerView一加载出来就执行啦，哪怕我们还看不到这个view，然后还有一些会在使用过程中混乱调用。</p><p>其实原因也很简单，因为内部会把这些controller的view加到collectionView的cell上，所以系统的生命周期都被打乱啦。</p><p>解决办法应该也只有一个——重写一套生命周期方法。更详细的代码，封装在了PZPageListContainerViewController中，PZPageListContainerView也提供了一些能够帮助实现的代理。详见源码</p><p>当然，除了生命周期以外，如果需要做的更加完善，我们还需要重屏幕旋转相关方法、状态栏相关方法。源码中这些都在controller中做了相关判断并调用正确的vc。</p><h2 id="问题七：PZPageListContainerView上touch事件意外cancel"><a href="#问题七：PZPageListContainerView上touch事件意外cancel" class="headerlink" title="#问题七：PZPageListContainerView上touch事件意外cancel"></a>#问题七：PZPageListContainerView上touch事件意外cancel</h2><p>如果我们想在我们这个类似相机的页面(先叫centerVC)上面做一些更加复杂的事情，比如利用touch事件让一个小view跟着手指移动。</p><p>我们在centerVC上加了这样的代码来做这个跟随手指移动的事情</p><pre><code>- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {    UITouch *touch = [touches anyObject];    CGPoint location = [touch locationInView:self.view];    _touchView.center = location;}- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {    NSLog(@&quot;touch end&quot;);}- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {    NSLog(@&quot;touch cancel&quot;);}</code></pre><p>首先我们会遇到collectionView的滑动同时被触发的问题，所以我们需要添加一个collectionView的禁用接口给外部根据业务需求来在需要的时候禁掉collectionView的滑动。</p><p>然后再次滑动我们加的touchView，会发现稍微动一下以后，它就不动了，看log是touchCancel执行了，这看起来非常的诡异，让我们很是头大。</p><p>我们一番搜索后找到了解答，博主自己提出了问题，后来自己研究解决啦：<a href="http://iphonedevsdk.com/forum/iphone-sdk-development/49840-touchescancelled-called-unexpectedly.html#post286709" target="_blank" rel="noopener">touchesCancelled called unexpectedly</a></p><p>简单点说，scrollView有这么一个参数(没错，说白了又是collectionView引起的)</p><pre><code>@property(nonatomic) BOOL canCancelContentTouches;    // default is YES. if NO, then once we start tracking, we don&#39;t try to drag if the touch moves. this has no effect on presses</code></pre><p>注释写到，当返回NO的时候，scrollView就不会跟随手指移动啦。而其实正是我们当前需求所需要的。</p><p>我们在实践中发现这个参数能解决问题，但是不是特别好用，它太过武断而一刀切，所以我们继续摸索，找到了这么个更好用的方法</p><pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view;// called before scrolling begins if touches have already been delivered to a subview of the scroll view. // if it returns NO the touches will continue to be delivered to the subview and scrolling will not occur// default returns YES if view isn&#39;t a UIControl// not called if canCancelContentTouches is NO</code></pre><blockquote><p>这个回调方法的主要作用是能够改变touches的分发，默认是YES表示需要继续分发touches。当返回NO时，就会被打断。需要注意的是，<strong>它不是打断scrollView的touches事件，而是打断传进来的view的touches事件</strong>。</p></blockquote><p>原本这个回调是影响scrollView上的subView的，但是这里我们把collectionView的panGesture直接移到了PZPageListContainerView上，而我们的centerVC所在的backgroundView是PZPageListContainerView的subView，这就导致collectionView和centerVC的view形成了一个假的父子关系。</p><p>搞清楚了原理以后，我们在collectionView中添加以下代码，就能解决问题啦</p><pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view {    return self.scrollEnabled &amp;&amp; self.panGestureRecognizer.enabled;}// 当collectionView可以滑动时，打断subView的touches，否则不打断。</code></pre><h2 id="End"><a href="#End" class="headerlink" title="#End"></a>#End</h2><p>至此，整个框架也就基本结束啦。过程中遇到了很多很多问题都是因为scrollView的叠加导致的，其中的一些比较麻烦的问题，也基本都帮大家扫了雷，希望其中的某些东西能够为大家解决问题提供思路。本文中涉及到的一些技术点，后期有空也会从这个demo的搭建过程中分离出来单独出文。更多细节，请参考<a href="https://github.com/panyfun/PZPageListContainerView" target="_blank" rel="noopener">源码</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文大约5100字，需要的阅读时间比较长，属于教程类，慎入。建议实在空闲或有空且有需求的时候跟着做(虽然一般有需求都不会有空)。直接上手请移步&lt;a href=&quot;https://panyfun.github.io/post/PZPageListContainer使用手册/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用说明书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将会讲述一个能够支持上下左右划入(类似SnapChat)或纵向/水平滑动(类似头条)的PageList框架的搭建过程及其中遇到的一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="开源共勉" scheme="http://pany.fun/categories/%E5%BC%80%E6%BA%90%E5%85%B1%E5%8B%89/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
      <category term="PZPageListContainer" scheme="http://pany.fun/tags/PZPageListContainer/"/>
    
  </entry>
  
  <entry>
    <title>layoutSubviews触发时机解析</title>
    <link href="http://pany.fun/post/layoutsubviews/"/>
    <id>http://pany.fun/post/layoutsubviews/</id>
    <published>2017-06-22T08:11:28.000Z</published>
    <updated>2018-09-21T01:55:16.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文约800字，将会讲述个人对LayoutSubviews的一些更加精简的总结</p><a id="more"></a><h5 id="原创文章，转载请注明来源-pany-fun"><a href="#原创文章，转载请注明来源-pany-fun" class="headerlink" title="!!!原创文章，转载请注明来源: pany.fun"></a><strong>!!!原创文章，转载请注明来源: <a href="http://pany.fun">pany.fun</a></strong></h5><p><strong>本文的相关测试demo</strong>: <a href="https://github.com/panyfun/BlogDemo/tree/master/20180222_LayoutSubview" target="_blank" rel="noopener">layoutSubDemo</a></p><p>测试环境：Xcode9.2、iPhone7模拟器、iOS11.2</p><h2 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h2><p>关于layoutSubviews什么时候触发的问题，其实网上已经有很多同学总结过啦。但是每个人的总结都大同小异，列了七八条，不是那么容易记住的。本文将在前人的基础上上进一步耕耘，进行部分解析和总结。</p><p>首先我们先来大致看看layoutSubviews。</p><p>顾名思义，它应该是用来处理布局的，而且是<strong>处理子视图的布局</strong>（这个点是很重要的）。也就是说，在某些情况下，view会在可能需要修改子视图的布局的时候触发layoutSubviews。</p><h2 id="普通视图的layoutSubviews的触发时机"><a href="#普通视图的layoutSubviews的触发时机" class="headerlink" title="#普通视图的layoutSubviews的触发时机"></a>#普通视图的layoutSubviews的触发时机</h2><p>先放结论：</p><p><strong><code>· 当size发生变化的时候，会先触发父视图的layoutSubviews，再触发自己的layoutSubviews。修改origin无任何调用。</code></strong></p><p>具体的来说，除了addSubview以及setNeedLayout这种特殊情况外，layoutSubviews的触发时机只有一种，就是在size发生变化的时候，我看到很多博客把它描述为frame变化，其实是不准确的。网上很多人总结的一些点，其实归根结底，也就是这一点。</p><p>但是从更加清晰的角度来说，这一条是需要拆分成 父视图的 与 自己的 两部分来理解的。</p><p><strong>修改自己的size调用自己的layoutSubViews</strong>很好理解，因为大小变了，可能要重新布局子视图。</p><p><strong>修改自己的origin不会调用自己的layoutSubViews</strong>也是比较好理解的，因为子视图是在自己的坐标系内布局的，自己的坐标系并没有变。</p><p><strong>修改自己的size调用父视图的layoutSubviews</strong> 以及 <strong>修改自己的origin不会调用父视图的layoutSubviews</strong>都不太好理解，暂时没有找到相关描述与解释。🤣</p><h2 id="UIScrollView类型视图的layoutSubviews的触发时机"><a href="#UIScrollView类型视图的layoutSubviews的触发时机" class="headerlink" title="#UIScrollView类型视图的layoutSubviews的触发时机"></a>#UIScrollView类型视图的layoutSubviews的触发时机</h2><p>UIScrollView与普通的视图不一样的点在于，UIScrollView的contentSize和视图本身的size是可以不相等的。这使得在layoutSubviews触发方面它也有一些普通视图之外的特性。</p><p><strong><code>· 当scrollView的offset发生变化时，scrollview会触发自己layoutSubviews。</code></strong></p><p><strong>注意：修改contentSize没有任何触发</strong></p><p>这也给我们实现某些特殊需求提供了新思路。</p><h2 id="测试过程了解一下"><a href="#测试过程了解一下" class="headerlink" title="#测试过程了解一下"></a>#测试过程了解一下</h2><p><strong>本文的相关测试demo</strong>: <a href="https://github.com/panyfun/BlogDemo/tree/master/BlogDemo/20180222_LayoutSubview" target="_blank" rel="noopener">layoutSubDemo</a></p><p>视图结构上，有 viewA 和 viewB， viewA 是 viewB的父视图。为了方便知道layoutSubviews的触发，我们使用了自己的view类，继承自UIView，并重写了layoutSubviews。</p><p>然后增加了一个viewC，继承自一个UIScrollView的子类，用来观察滚动对layoutSubviews的触发问题。</p><p>其它的就比较简单了，改改size，看看打印，改改origin，看看打印。相关细节可以在代码中去了解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文约800字，将会讲述个人对LayoutSubviews的一些更加精简的总结&lt;/p&gt;
    
    </summary>
    
      <category term="日常学习" scheme="http://pany.fun/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="iOS" scheme="http://pany.fun/tags/iOS/"/>
    
  </entry>
  
</feed>
